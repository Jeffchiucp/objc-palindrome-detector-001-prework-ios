{
  "name": "Objc-palindrome-detector-001-prework-ios",
  "tagline": "",
  "body": "# Code-Along: Palindrome Detector\r\n\r\n# Added solution to the GitHub\r\n\r\n## Objectives\r\n\r\n1. Declare methods in the `.h` header file using proper syntax.\r\n2. Define methods in the `.m` implementation file using proper syntax.\r\n3. Engage a problem to be solved in code by breaking the approach down into smaller steps.\r\n4. Solve each step sequentially in increasing levels of complexity.\r\n5. Check your code's behavior periodically with `NSLog()` as you progress in your solution.\r\n6. Call another method in the same file by using the `self` keyword.\r\n\r\n### Optional \r\n7. Memorize some palindromes that you can use to impress your friends.\r\n\r\n## Introduction\r\n\r\nA [palindrome](https://en.wikipedia.org/wiki/Palindrome) is a word, phrase, or sentence whose letters are exactly mirrored around the center letter. Some examples include:\r\n\r\n*racecar*  \r\n*Bob*  \r\n*Kanakanak*  (a city in Alaska)  \r\n*Aibohphobia*  (the fear of palindromes)   \r\n*never odd or even*  \r\n*I prefer pi*  \r\n*Flee to me, remote elf.*  \r\n*Norma is as selfless as I am, Ron.*  \r\n*No sir! Away! A papaya war is on.*\r\n\r\nThe qualification of a palindrome typically ignores spaces, punctuation, and capitalization, judging only the order of the letters themselves. Essentially, when a palindrome is reversed, its letters fall into the same order.\r\n\r\nIn this code-along we're going to write a method that can judge whether or not a particular string qualifies as a palindrome. We're going to start with judging a single all-lowercase word, and then add complexity to allow the method to handle capitalization, spaces, and punctuation. We'll call this method `stringIsPalindrome:`.\r\n\r\nThe easiest way to judge a palindrome is simply to compare it to its reverse. However, there is no string reversal method built into the Objective-C language so we'll have to write this functionality ourselves. We'll accomplish this by writing another method called `stringByReversingString:` that we can call from within the `stringIsPalindrome` method by using the `self` keyword as the recipient object.\r\n\r\n## Instructions\r\n\r\nFork and clone this lab. \r\n\r\n### I. Declare Methods In The Header File\r\n\r\nOpen the `objc-palindrome-detector.xcodeproj` file and navigate to the `FISAppDelegate.h` header file. You should see the following code:\r\n\r\n```objc\r\n//  FISAppDelegate.h\r\n\r\n#import <UIKit/UIKit.h>\r\n\r\n@interface FISAppDelegate : UIResponder <UIApplicationDelegate>\r\n\r\n@property (strong, nonatomic) UIWindow *window;\r\n\r\n/**\r\n \r\n * Declare your methods here.\r\n \r\n */\r\n\r\n@end\r\n```\r\nDeclare two methods inside the `@interface` section, between the `@property` statement and the `@end` statement:\r\n\r\n* `stringIsPalindrome:` which takes one `NSString` argument called `string` and returns a `BOOL`, and\r\n* `stringByReversingString:` which takes one `NSString` argument called `string` and returns an `NSString`.\r\n\r\nAfter declaring these methods, your `FISAppDelegate.h` header file should look something like this:\r\n\r\n```objc\r\n//  FISAppDelegate.h\r\n\r\n#import <UIKit/UIKit.h>\r\n\r\n@interface FISAppDelegate : UIResponder <UIApplicationDelegate>\r\n\r\n@property (strong, nonatomic) UIWindow *window;\r\n\r\n- (BOOL)stringIsPalindrome:(NSString *)string;\r\n\r\n- (NSString *)stringByReversingString:(NSString *)string;\r\n\r\n@end\r\n```\r\nGreat!\r\n\r\n### II. Define Method Implementations\r\n\r\nNow, navigate to the `FISAppDelegate.m` implementation file. *Below* the ending curly brace of the `application:didFinishLaunchingWithOptions:` method, but *above* the `@end` statement, use autocomplete to define both methods with default returns:\r\n\r\n* `stringIsPalindrome:` should `return NO;`, and\r\n* `stringByReversingString:` should `return nil;`.\r\n\r\nYour `FISAppDelegate.m` file should now look something like this:\r\n\r\n```objc\r\n//  FISAppDelegate.m\r\n\r\n#import \"FISAppDelegate.h\"\r\n\r\n@implementation FISAppDelegate\r\n\r\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\r\n    // Override point for customization after application launch.\r\n    \r\n    /**\r\n     \r\n     * Write your check code here.\r\n     \r\n     */\r\n\r\n    // do not alter\r\n    return YES;  //\r\n}   ///////////////\r\n\r\n/**\r\n \r\n * Implement your methods here.\r\n \r\n */\r\n\r\n- (BOOL)stringIsPalindrome:(NSString *)string {\r\n   return NO;\r\n}\r\n\r\n- (NSString *)stringByReversingString:(NSString *)string {\r\n    return nil;\r\n}\r\n\r\n@end\r\n```\r\n\r\n### III. Reversing a String\r\n\r\nBecause the logic of our `stringIsPalindrome:` method depends on our ability to reverse a string, let's start by writing out the `stringByReversingString:` method that we declared. Our goal is take whatever string variable is passed into the `string` argument (also \"parameter\") and return its exact reverse at the end of the method.\r\n\r\nHow would we approach this goal with a word or sentence written on paper? Couldn't we simply start at the end of the word or sentence, moving backwards while copying each letter onto a new line? Of course we could!\r\n\r\nHow could we represent this process in code? Well, we already know that strings are made up of individual characters that are arranged by index. So, could we simply start with the character at the string's highest index and work backwards, copying each character into a new string? Of course we could!\r\n\r\n**Advanced:** *There are more efficient ways to reverse a string, but this is perhaps the simplest one to understand.*\r\n\r\nOne possible implementation of this process in Objective-C is written below:\r\n\r\n```objc\r\n- (NSString *)stringByReversingString:(NSString *)string {\r\n\r\n    NSString *result = @\"\";\r\n    \r\n    for (NSUInteger i = [string length]; i > 0; i--) {\r\n        NSUInteger index = i - 1;\r\n        unichar c = [string characterAtIndex:index];\r\n        result = [result stringByAppendingFormat:@\"%C\", c];\r\n    }\r\n    \r\n    return result;\r\n}\r\n```\r\n\r\nLet's walk through what this method is doing:\r\n\r\n1. Creating a new `NSString` variable called `result` that will be the container for the reversed string that will get assembled one character at a time.\r\n2. Declaring a `for` loop whose counter begins at the size of the string's length and counts down (decrements) to `1` (*remember that the length will always be one more than the maximum index*).\r\n3. Defines an integer called `index` that is one less than the current value of `i`. This is to solve the off-by-one difference between the value of the string's `length` and the value of its highest index.\r\n4. Finds the next character (`unichar c`) to be copied by using the `index` integer to call the `characterAtIndex:` method on the argument `string`.\r\n5. Appends that character (`c`) to the end of the `result` string. This uses the `unichar` format specifier (`%C`) to interpolate the character variable `c` into a string that can be appended normally.\r\n6. After the loop counts down to `1`, the `result` string should be complete, and it is returned at the end of the method.\r\n\r\nOnce you have a conceptual understanding of this implementation, copy it into your code.\r\n\r\n### IV. Checking a Method Return\r\n\r\nLet's check that our new `stringByReversingString:` method works by calling it from the `application:didFinishLaunchingWithOptions:` method and `NSLog()`ing the return! We can call our new method from within the same file by sending a message to the `self` keyword.\r\n\r\n1. Inside `application:didFinishLaunchingWithOptions:`, create an `NSString` variable called `palindrome` and set it to the string literal `@\"palindrome\"`:\r\n  * `NSString *palindrome = @\"palindrome\";`\r\n2. Now create another `NSString` variable called `reversed` and use it to capture the return of calling `stringByReversingString:` on `self` with `palindrome` submitted as the method argument:\r\n  * `NSString *reversed = [self stringByReversingString:palindrome];`\r\n3. Finally, print `palindrome` and `reversed` to the console to inspect the method:\r\n  * `NSLog(@\"%@ : %@\", palindrome, reversed);`\r\n\r\nThis should print: `palindrome : emordnilap`.\r\n\r\nHooray! Our first method works!\r\n\r\n### V. Detecting a Palindrome\r\n\r\nNow the we've verified that our string reversal method works, we can get to work on the implementation of our `stringIsPalindrome:` method.\r\n\r\nIn our first pass at this method, let's use the simplest case for our first example: an all-lowercase single word such as \"*racecar*\". We'll add complexity to our method later. For now, let's just make sure we can get the core of the logic down.\r\n\r\nLet's conceptualize the steps we need to take:\r\n\r\n* We need to get the reverse of the string we're testing,\r\n* then we can compare the original string to its reverse,\r\n* then we can return the result of that comparison, which will be a `BOOL`.\r\n\r\nThat sounds like a solid plan! Now let's write the implementation:\r\n\r\n1. Create a new `NSString` variable called `reverse` and use it to capture the return of calling `stringByReversingString:` on `self` with the `string` argument variable submitted as the method argument:\r\n  * `NSString *reverse = [self stringByReversingString:string];`\r\n2. Create a new `BOOL` variable called `stringIsEqualToReverse` and use it to capture the return of calling the `isEqualToString:` method on `string` with `reverse` submitted as the argument:\r\n  * `BOOL stringIsEqualToReverse = [string isEqualToString:reverse];`\r\n3. Return the `stringIsEqualToReverse` variable to end the method implementation:\r\n  * `return stringIsEqualToReverse;`\r\n\r\nYour method implementation should look something like this:\r\n\r\n```objc\r\n- (BOOL)stringIsPalindrome:(NSString *)string {\r\n       \r\n    NSString *reverse = [self stringByReversingString:string];\r\n    \r\n    BOOL stringIsEqualToReverse = [string isEqualToString:reverse];\r\n    \r\n    return stringIsEqualToReverse;\r\n}\r\n```\r\n\r\n### VI. Check The Implementation\r\n\r\nJust like we checked the `stringByReversingString:` method before, let's use local variables and an `NSLog()` within the `application:didFinishLaunchingWithOptions:` method to check that our method can handle the case of \"*racecar*\".\r\n\r\n1. Move up to the `application:didFinishLaunchingWithOptions:` method. Create a new `NSString` variable called `racecar` and assign it to the string literal `@\"racecar\"`:\r\n  * `NSString *racecar = @\"racecar\";`\r\n2. Now, create a new `BOOL` variable called `racecarIsPalindrome` and use it to capture the return of calling `stringIsPalindrome:` on `self` with `racecar` submitted as the method argument:\r\n  * `BOOL racecarIsPalindrome = [self stringIsPalindrome:racecar];`\r\n3. Finally, `NSLog()` the variables together to view the result:\r\n  * `NSLog(@\"%d : %@\", racecarIsPalindrome, racecar);`\r\n\r\nThis should print: `1 : racecar`, meaning that \"*racecar*\" **is** a palindrome.\r\n\r\nNow, let's check a string that **isn't** a palindrome. Reuse the `palindrome` string to verify that `stringIsPalindrome:` returns \"NO\" for a string that doesn't match its reverse.\r\n\r\n1. Create a new `BOOL` variable called `palindromeIsPalindrome` and use it to capture the return of calling `stringIsPalindrome:` on `self` with `palindrome` submitted as the method argument:\r\n  * `BOOL palindromeIsPalindrome = [self stringIsPalindrome:palindrome];`\r\n2. Now, `NSLog()` these variables together to view the result:\r\n  * `NSLog(@\"%d : %@\", palindromeIsPalindrome, palindrome);`\r\n\r\nThis should print: `0 : palindrome`, meaning that \"*palindrome*\" is **not** a palindrome (`BOOL ironic = YES;`).\r\n\r\n## Adding Complexity\r\n\r\n### VII. Ignoring Typecase\r\n\r\nLet's improve our `stringIsPalindrome:` method to allow it to handle uppercase letters in strings. Right now, evaluating the actual palindromes \"*Bob*\", \"*Kanakanak*\", and \"*Aibohphobia*\" will all return \"NO\" because they contain a capital letter. Verify this by adding these checks into the `application:didFinishLaunchingWithOptions:` method in the same style as evaluating \"*racecar*\":\r\n\r\n**Note:** *We suggest you get the practice of typing these lines out manually. Use the code block below as a guide without copy/pasting from it.*\r\n\r\n```objc\r\n// within application:didFinishLaunchingWithOptions:\r\n\r\n// single word, with uppercase\r\nNSString *bob = @\"Bob\";\r\nBOOL bobIsPalindrome = [self stringIsPalindrome:bob];\r\nNSLog(@\"%d : %@\", bobIsPalindrome, bob);\r\n    \r\nNSString *kanakanak = @\"Kanakanak\";\r\nBOOL kanakanakIsPalindrome = [self stringIsPalindrome:kanakanak];\r\nNSLog(@\"%d : %@\", kanakanakIsPalindrome, kanakanak);\r\n    \r\nNSString *aibohphobia = @\"Aibohphobia\";\r\nBOOL aibohphobiaIsPalindrome = [self stringIsPalindrome:aibohphobia];\r\nNSLog(@\"%d : %@\", aibohphobiaIsPalindrome, aibohphobia);\r\n```\r\nRunning the program now should print these three lines with zeroes:\r\n\r\n```\r\n0 : Bob\r\n0 : Kanakanak\r\n0 : Aibohphobia\r\n```\r\nThe implementation of handling these additional cases in `stringIsPalindrome:` is relatively simple: we just need to lowercase the `string` argument before we evaluate it, right? Let's try it:\r\n\r\n1 — Insert a statement that creates a new `NSString` variable called `lowercase` use to capture the return of calling the `lowercase` method on the `string` argument. Then refactor the string comparison to evaluate `lowercase` against `reverse`:\r\n\r\n```objc\r\n- (BOOL)stringIsPalindrome:(NSString *)string {\r\n    \r\n    NSString *reverse = [self stringByReversingString:string];\r\n    \r\n    NSString *lowercase = [string lowercaseString];\r\n\r\n    BOOL stringIsEqualToReverse = [lowercase isEqualToString:reverse];\r\n    \r\n    return stringIsEqualToReverse;\r\n}\r\n```\r\nNow, run the program again. It will still print our three palindromes with zeroes:\r\n\r\n```\r\n0 : Bob\r\n0 : Kanakanak\r\n0 : Aibohphobia\r\n```\r\nWhat did we do wrong? Let's add an `NSLog()` right before the comparison to inspect the strings:\r\n\r\n```objc\r\n- (BOOL)stringIsPalindrome:(NSString *)string {\r\n    \r\n    NSString *reverse = [self stringByReversingString:string];\r\n    \r\n    NSString *lowercase = [string lowercaseString];\r\n\r\n    NSLog(@\"lowercase: %@, reverse: %@\", lowercase, reverse);\r\n    BOOL stringIsEqualToReverse = [lowercase isEqualToString:reverse];\r\n    \r\n    return stringIsEqualToReverse;\r\n}\r\n```\r\nRunning the program will cause this to print:\r\n\r\n```\r\nlowercase: bob, reverse: boB\r\n0 : Bob\r\nlowercase: kanakanak, reverse: kanakanaK\r\n0 : Kanakanak\r\nlowercase: aibohphobia, reverse: aibohphobiA\r\n0 : Aibohphobia\r\n```\r\nIt looks like we reversed the string *before* we lowercased it, which means that we're comparing the lowercased version to a reversed version that contains an uppercase letter in it. This causes the comparison to fail.\r\n\r\nTo fix this, we should be move the statement creating `lowercase` to above the statement creating the `reverse` string, and refactor `reverse`'s assignment to use `lowercase` as its method argument instead of `string`:\r\n\r\n```objc\r\n- (BOOL)stringIsPalindrome:(NSString *)string {\r\n    \r\n    NSString *lowercase = [string lowercaseString];\r\n    \r\n    NSString *reverse = [self stringByReversingString:lowercase];\r\n    \r\n    NSLog(@\"lowercase: %@, reverse: %@\", lowercase, reverse);\r\n    BOOL stringIsEqualToReverse = [lowercase isEqualToString:reverse];\r\n    \r\n    return stringIsEqualToReverse;\r\n}\r\n```\r\nNow running the program should be able to handle the checks with our capitalized strings, and print them with `1`s:\r\n\r\n```\r\nlowercase: bob, reverse: bob\r\n1 : Bob\r\nlowercase: kanakanak, reverse: kanakanak\r\n1 : Kanakanak\r\nlowercase: aibohphobia, reverse: aibohphobia\r\n1 : Aibohphobia\r\n```\r\nAwesome! Now we can handle proper nouns properly! Delete the `NSLog()` from the method before moving on; we don't need it anymore.\r\n\r\n### VIII. Removing Spaces\r\n\r\nSince phrases can qualify as a palindromes, let's improve our `stringIsPalindrome:` method to evaluate strings that contain spaces. Let's start by adding some new checks to the `application:didFinishLaunchingWithOptions:` method for the phrases \"*this is not a palindrome*\" (as a control check), \"*never odd or even*\", and \"*I prefer pi*\":\r\n\r\n**Note:** *We suggest you get the practice of typing these lines out manually. Use the code block below as a guide without copy/pasting from it.*\r\n\r\n```objc\r\n//within application:didFinishLaunchingWithOptions:\r\n\r\nNSString *notAPalindrome = @\"this is not a palindrome\";\r\nBOOL notAPalindromeIsPalindrome = [self stringIsPalindrome:notAPalindrome];\r\nNSLog(@\"%d : %@\", notAPalindromeIsPalindrome, notAPalindrome);\r\n    \r\nNSString *neverOdd = @\"never odd or even\";\r\nBOOL neverOddIsPalindrome = [self stringIsPalindrome:neverOdd];\r\nNSLog(@\"%d : %@\", neverOddIsPalindrome, neverOdd);\r\n    \r\nNSString *iPreferPi = @\"I prefer pi\";\r\nBOOL iPreferPiIsPalindrome = [self stringIsPalindrome:iPreferPi];\r\nNSLog(@\"%d : %@\", iPreferPiIsPalindrome, iPreferPi);\r\n```\r\n\r\nRunning the program should print all three phrases with zeroes:\r\n\r\n```\r\n0 : this is not a palindrome\r\n0 : never odd or even\r\n0 : I prefer pi\r\n```\r\nNow let's edit our `stringIsPalindrome:` method again by adding logic at the top that removes the spaces. We can accomplish this by using the `stringByReplacingOccurrencesOfString:withString:` (say that 10 times fast).\r\n\r\nCreate a new `NSString` variable called `spaceless` and use it to capture the return of calling `stringByReplacingOccurrencesOfString:withString:` on the `string` argument variable; the first method argument should be a string literal containing a single space (`@\" \"`) and the second method argument should be an empty string literal (`@\"\"`).\r\n\r\nRefactor the rest of the method implementation to use `spaceless` instead of `string` (this should only affect one statement):\r\n\r\n```objc\r\n- (BOOL)stringIsPalindrome:(NSString *)string {\r\n       \r\n    NSString *spaceless = [string stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];\r\n    \r\n    NSString *lowercase = [spaceless lowercaseString];\r\n    \r\n    NSString *reverse = [self stringByReversingString:lowercase];\r\n    \r\n    BOOL stringIsEqualToReverse = [lowercase isEqualToString:reverse];\r\n    \r\n    return stringIsEqualToReverse;\r\n}\r\n```\r\nNow let's run the program again. Our palindrome phrases should now print with `1`s:\r\n\r\n```\r\n0 : this is not a palindrome\r\n1 : never odd or even\r\n1 : I prefer pi\r\n```\r\n\r\n### IX. Removing Punctuation\r\n\r\nFor our final trick, let's add the functionality to our `stringIsPalindrome:` method so that can accommodate palindromes that are full sentences. (That means punctuation!) Let's start by adding some checks by utilizing the palindrome sentences \"*Flee to me, remote elf.*\", \"*Norma is as selfless as I am, Ron.*\", and \"*No sir! Away! A papaya war is on.*\":\r\n\r\n**Note:** *We suggest you get the practice of typing these lines out manually. Use the code block below as a guide without copy/pasting from it.*\r\n\r\n```objc\r\n//within application:didFinishLaunchingWithOptions:\r\n\r\n// full sentences with punctuation and capitalization\r\nNSString *fleeToMe = @\"Flee to me, remote elf.\";\r\nBOOL fleeToMeIsPalindrome = [self stringIsPalindrome:fleeToMe];\r\nNSLog(@\"%d : %@\", fleeToMeIsPalindrome, fleeToMe);\r\n    \r\nNSString *norma = @\"Norma is as selfless as I am, Ron.\";\r\nBOOL normaIsPalindrome = [self stringIsPalindrome:norma];\r\nNSLog(@\"%d : %@\", normaIsPalindrome, norma);\r\n    \r\nNSString *papayaWar = @\"No sir! Away! A papaya war is on.\";\r\nBOOL papayaWarIsPalindrome = [self stringIsPalindrome:papayaWar];\r\nNSLog(@\"%d : %@\", papayaWarIsPalindrome, papayaWar);\r\n```\r\nRunning the program now should print these sentences with zeroes:\r\n\r\n```\r\n0 : Flee to me, remote elf.\r\n0 : Norma is as selfless as I am, Ron.\r\n0 : No sir! Away! A papaya war is on.\r\n```\r\n\r\nWe can remove the punctuation characters from the `string` argument variable by using `stringByReplacingOccurrencesOfString:withString:` again. If we collect our punctuation characters into an array, we can iterate over each punctuation string with a `for` loop, replacing every punctuation character in the string with an empty string instead. Let's do this now at the top of the `stringIsPalindrome:` method implementation:\r\n\r\n1. Create a new `NSArray` called `punctuations` and assign it to an array literal containing the string literals for the six common punctuation characters `.`, `,`, `!`, `?`, `:`, and `;` (period, comma, exclamation point, question mark, colon, and semicolon):\r\n  * `NSArray *punctuations = @[ @\".\", @\",\", @\"!\", @\"?\", @\":\", @\";\" ];`\r\n2. Create a new `NSString` variable called `withoutPunctuation` and assign to a copy of the `string` argument variable:\r\n  * `NSString *withoutPunctuation = [string copy];`\r\n3. Start a `for` loop that iterates over the `punctuations` array:\r\n  * `for (NSUInteger i = 0; i < [punctuations count]; i++) {...}`\r\n4. Within the `for` loop, create new `NSString` variable called `punctuation` and assign it to the subscript of the `punctuations` array using the current value of `i`:\r\n  * `NSString *punctuation = punctuations[i];`\r\n5. Still within the `for` loop, reassign the `withoutPunctuation` variable to capture a call of the `stringByReplacingOccurrencesOfString:withString:` method on the `withoutPunctuation` variable (itself). The first argument should be the `punctuation` string variable, and the second argument should be an empty string literal (`@\"\"`):\r\n  * `withoutPunctuation = [withoutPunctuation stringByReplacingOccurrencesOfString:punctuation withString:@\"\"];`\r\n6. Refactor the creation of the `spaceless` variable to use `withoutPunctuation` instead of the `string` argument variable:\r\n  * `NSString *spaceless = [withoutPunctuation stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];`\r\n \r\nThe `stringIsPalindrome:` should now look something like this:\r\n\r\n```objc\r\n- (BOOL)stringIsPalindrome:(NSString *)string {\r\n    \r\n    NSArray *punctuations = @[ @\".\", @\",\", @\"!\", @\"?\", @\":\", @\";\" ];\r\n    NSString *withoutPunctuation = [string copy];\r\n    \r\n    for (NSUInteger i = 0; i < [punctuations count]; i++) {\r\n        NSString *punctuation = punctuations[i];\r\n        withoutPunctuation = [withoutPunctuation stringByReplacingOccurrencesOfString:punctuation withString:@\"\"];\r\n    }\r\n    \r\n    NSString *spaceless = [withoutPunctuation stringByReplacingOccurrencesOfString:@\" \" withString:@\"\"];\r\n        \r\n    NSString *lowercase = [spaceless lowercaseString];\r\n    \r\n    NSString *reverse = [self stringByReversingString:lowercase];\r\n    \r\n    BOOL stringIsEqualToReverse = [lowercase isEqualToString:reverse];\r\n    \r\n    return stringIsEqualToReverse;\r\n}\r\n```\r\nRun the program to see how well our method handles the palindrome sentences. It should print all three of them now with `1`s:\r\n\r\n```\r\n1 : Flee to me, remote elf.\r\n1 : Norma is as selfless as I am, Ron.\r\n1 : No sir! Away! A papaya war is on.\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}